# -*- coding: utf-8 -*-
"""Submission_Proyek_Analisis_Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10YmbsuSOLIVPQN0IRajBws1TS_F_NJmj
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Proyek Analisis Data: [Input Nama Dataset]
- **Nama:** Bayu Frassetyo Wibowo
- **Email:** bayufrassetyo@gmail.com
- **ID Dicoding:** bayufrassetyo

## Menentukan Pertanyaan Bisnis

- Produk apa saja yang menunjukkan performa penjualan terbaik dan terburuk di E-commerce?
- Bagaimana pola tren penjualan E-commerce selama periode waktu tertentu?
- Berapa jumlah pendapatan yang dihasilkan oleh E-commerce dalam periode beberapa bulan terakhir?
- Apa saja ulasan dan rating yang diberikan oleh pelanggan kepada E-commerce, dan bagaimana persebarannya?
- Bagaimana distribusi demografis pelanggan dan apakah ada variasi dalam preferensi pembelian di antara mereka?

## Import Semua Packages/Library yang Digunakan
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import folium
import matplotlib.image as mpimg
import textwrap
import datetime as dt
import matplotlib

"""## Data Wrangling

### Gathering Data
"""

# Memuat data dari file CSV
customers_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/customers_dataset.csv')
geolocation_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/geolocation_dataset.csv')
order_items_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/order_items_dataset.csv')
order_payments_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/order_payments_dataset.csv')
order_reviews_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/order_reviews_dataset.csv')
orders_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/orders_dataset.csv')
products_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/products_dataset.csv')
product_category_name_translation_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/product_category_name_translation.csv')
sellers_df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Dataset/sellers_dataset.csv')

# prompt: Menggunakan customers_df DataFrame: customers_df

# Display the dataframe
customers_df.head()

# prompt: Menggunakan geolocation_df

# Create a new DataFrame called geolocation_df from the customer data.
geolocation_df = customers_df[["customer_zip_code_prefix", "customer_city", "customer_state"]].copy()

# Display the first few rows of the new DataFrame.
geolocation_df.head()

# prompt: Menggunakan order_items_df
order_items_df.head()

# prompt: Menggunakan order_payments_df
order_payments_df.head()

# prompt: Menggunakan order_reviews_df
order_reviews_df.head()

# prompt: Menggunakan orders_df

# Display the first 5 rows of the order_reviews dataframe.
orders_df.head()

# prompt: Menggunakan products_df

# Kode ini akan menampilkan 5 baris pertama dari dataframe yang disediakan 'orders_df'.
# Ganti dengan operasi aktual pada 'products_df' setelah tersedia.

products_df.head()

# prompt: Menggunakan product_category_name_translation_df

product_category_name_translation_df.head()

# prompt: Menggunakan sellers_df

# Untuk menampilkan bingkai data, gunakan:
sellers_df.head()

"""**Insight:**
- Data pelanggan berhasil dimuat dengan baik, menunjukkan beberapa baris pertama untuk verifikasi.
- Data dari berbagai file CSV digabungkan untuk analisis lebih lanjut.
- Data ulasan memberikan wawasan tentang kepuasan pelanggan melalui rating dan komentar.
- Data pesanan mencakup detail seperti status, waktu pembelian, dan waktu pengiriman. Ini memungkinkan evaluasi efisiensi proses pemesanan dan pengiriman.
- Data produk dan kategorinya menyediakan informasi penting tentang atribut produk serta klasifikasinya.
- Data penjual memberikan detail lokasi penjual, membantu menganalisis distribusi geografis penjual.

### Assessing Data

1. Data customers_df
"""

# prompt: customers_df.info()

customers_df.info()

"""Informasi Kolom dan Tipe Data:

- customers_df memiliki 99,441 baris dan 5 kolom.

- Kolom terdiri dari customer_id, customer_unique_id, customer_zip_code_prefix, customer_city, dan customer_state.

- Kolom customer_zip_code_prefix bertipe int64 sementara kolom lainnya bertipe object.
"""

# prompt: customers_df.isna().sum()

customers_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", customers_df.duplicated().sum())

print("Jumlah duplikasi: ", customers_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: customers_df.describe(include=('all'))

customers_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom customer_zip_code_prefix menunjukkan rata-rata, minimum, dan maksimum yang mencerminkan variasi kode pos pelanggan.

- Kolom customer_city dan customer_state memberikan informasi tentang distribusi geografis pelanggan.

**Insight: Data customers_df**
- Data pelanggan di customers_df bersih dan lengkap, tanpa adanya missing values atau duplikasi.

- Informasi dalam dataset ini sangat berguna untuk analisis demografis pelanggan berdasarkan kota dan negara bagian, serta untuk memahami persebaran geografis pelanggan berdasarkan kode pos.

2. Data geolocation_df
"""

# prompt: geolocation_df

geolocation_df.info()

"""Informasi Kolom dan Tipe Data:

- geolocation_df memiliki 99,441 baris dan 3 kolom.

- Kolom terdiri dari customer_zip_code_prefix, customer_city, dan customer_state.

- Kolom customer_zip_code_prefix bertipe int64 sementara kolom lainnya bertipe object.
"""

# prompt: geolocation_df.isna().sum()

geolocation_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", geolocation_df.duplicated().sum())

print("Jumlah duplikasi: ", geolocation_df.duplicated().sum())

"""Duplikasi Data:

- Ditemukan 84,407 baris duplikasi di dalam dataset ini (Jumlah duplikasi: 84407), menunjukkan banyak entri yang berulang.
"""

# prompt: geolocation_df.describe(include=('all'))

geolocation_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom customer_zip_code_prefix menunjukkan variasi kode pos pelanggan.

- Kolom customer_city dan customer_state memberikan informasi tentang distribusi geografis pelanggan.

**Insight: Data geolocation_df**
- Data geografis di geolocation_df bersih dan lengkap, tanpa adanya missing values.

- Meskipun demikian, terdapat banyak duplikasi data yang perlu diperhatikan. Duplikasi ini mungkin perlu dihapus untuk analisis yang lebih akurat.

- Informasi dalam dataset ini sangat berguna untuk analisis demografis pelanggan berdasarkan kota dan negara bagian, serta untuk memahami persebaran geografis pelanggan berdasarkan kode pos.

3. Data order_items_df
"""

# prompt: order_items_df.info()

order_items_df.info()

"""Informasi Kolom dan Tipe Data:

- order_items_df memiliki 112,650 baris dan 7 kolom.

- Kolom terdiri dari order_id, order_item_id, product_id, seller_id, shipping_limit_date, price, dan freight_value. pada shipping_limit_date terdapat kesalahan dalam mempresentasikan datanya yaitu **object** bukan **date** berikut perbaikan code:

```
# Ini diformat sebagai kode
# Mengonversi kolom shipping_limit_date ke tipe datetime
order_items_df['shipping_limit_date'] = pd.to_datetime(order_items_df['shipping_limit_date'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(order_items_df.info())
```



- Kolom price dan freight_value, sedang untuk shipping_limit_date sudah berubah dari object menjadi datetime64[ns]
"""

# Mengonversi kolom shipping_limit_date ke tipe datetime
order_items_df['shipping_limit_date'] = pd.to_datetime(order_items_df['shipping_limit_date'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(order_items_df.info())

"""Informasi Kolom dan Data Tipe :
- Tipe data sudah sesuai, terutama shipping_limit_date yang telah dikonversi ke datetime64[ns], sehingga bisa digunakan untuk analisis keterlambatan pengiriman atau tren pesanan berdasarkan waktu.
"""

# prompt: order_items_df.isna().sum()

order_items_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", order_items_df.duplicated().sum())

print("Jumlah duplikasi: ", order_items_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: order_items_df.describe(include=('all'))

order_items_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom price menunjukkan variasi harga produk yang dipesan.

- Kolom freight_value memberikan informasi tentang biaya pengiriman untuk setiap item pesanan.

**Insight: Data order_items_df**
- Data pesanan di order_items_df bersih dan lengkap, tanpa adanya missing values atau duplikasi.

- Informasi dalam dataset ini sangat berguna untuk menganalisis performa penjualan produk, biaya pengiriman, dan detail setiap item pesanan yang dilakukan.

4. Data order_payment_df
"""

# prompt: order_payments_df.info()

order_payments_df.info()

"""Informasi Kolom dan Tipe Data:

- order_payments_df memiliki 103,886 baris dan 5 kolom.

- Kolom terdiri dari order_id, payment_sequential, payment_type, payment_installments, dan payment_value.

- Kolom payment_value bertipe float64, kolom payment_sequential dan payment_installments bertipe int64, sedangkan kolom lainnya bertipe object.
"""

# prompt: order_payments_df.isna().sum()

order_payments_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", order_payments_df.duplicated().sum())

print("Jumlah duplikasi: ", order_payments_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: order_payments_df.describe(include=('all'))

order_payments_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom payment_value menunjukkan variasi nilai pembayaran yang dilakukan pelanggan.

- Kolom payment_type menyediakan informasi tentang berbagai jenis metode pembayaran yang digunakan, seperti kartu kredit, debit, dan lainnya.

- Kolom payment_installments mengindikasikan jumlah cicilan yang dipilih oleh pelanggan.

**Insight: Data order_payment_df**
- Data pembayaran di order_payments_df bersih dan lengkap, tanpa adanya missing values atau duplikasi.

- Informasi dalam dataset ini sangat berguna untuk menganalisis preferensi metode pembayaran, jumlah cicilan, dan nilai transaksi rata-rata.

- Dataset ini mendukung pemahaman yang lebih baik tentang perilaku pembayaran pelanggan dan membantu dalam merancang strategi pembayaran yang lebih efektif.

5. Data order_reviews_df
"""

# prompt: order_reviews_df.info()

order_reviews_df.info()

"""Informasi Kolom dan Tipe Data:

- order_reviews_df memiliki 99,224 baris dan 7 kolom.

- Kolom terdiri dari review_id, order_id, review_score, review_comment_title, review_comment_message, review_creation_date, dan review_answer_timestamp. seharusnya **review_creation_date** dan **review_answer_timestamp** dipresentasikan **date** bukan **object**. berikut perbaikannya :

```
# Ini diformat sebagai kode
# Mengonversi kolom waktu ke tipe datetime
order_reviews_df['review_creation_date'] = pd.to_datetime(order_reviews_df['review_creation_date'], errors='coerce')
order_reviews_df['review_answer_timestamp'] = pd.to_datetime(order_reviews_df['review_answer_timestamp'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(order_reviews_df.info())
```



- Kolom review_score bertipe int64, sedangkan kolom lainnya bertipe object yang seharusnya date telah diperbaiki.
"""

# Mengonversi kolom waktu ke tipe datetime
order_reviews_df['review_creation_date'] = pd.to_datetime(order_reviews_df['review_creation_date'], errors='coerce')
order_reviews_df['review_answer_timestamp'] = pd.to_datetime(order_reviews_df['review_answer_timestamp'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(order_reviews_df.info())

"""âœ… Perubahan pada Tipe Data: Kolom Datetime untuk Analisis Respons Ulasan

Dalam dataset ini, terdapat dua kolom baru bertipe datetime64[ns]:

- 1ï¸âƒ£ review_creation_date â†’ Menunjukkan kapan pelanggan memberikan ulasan.
- 2ï¸âƒ£ review_answer_timestamp â†’ Menunjukkan kapan ulasan tersebut mendapatkan respons dari sistem atau penjual.

Dengan adanya dua kolom ini, kita bisa menghitung selisih waktu antara ulasan diberikan dan ditanggapi
"""

# prompt: order_reviews_df.isna().sum()

order_reviews_df.isna().sum()

"""Missing Values:

- Kolom review_comment_title dan review_comment_message memiliki banyak missing values. Hanya 87,656 baris yang terisi untuk review_comment_title dan 58,247 baris untuk review_comment_message.

- Kolom lainnya tidak memiliki missing values dan terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", order_reviews_df.duplicated().sum())

print("Jumlah duplikasi: ", order_reviews_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: order_reviews_df.describe(include=('all'))

order_reviews_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom review_score menunjukkan variasi nilai ulasan yang diberikan oleh pelanggan, membantu dalam mengukur tingkat kepuasan mereka.

- Kolom review_creation_date dan review_answer_timestamp memberikan informasi tentang kapan ulasan dibuat dan dijawab.

**Insight: Data order_payment_df**
- Data ulasan di order_reviews_df bersih dari duplikasi, meskipun terdapat banyak missing values di kolom review_comment_title dan review_comment_message.

- Informasi dalam dataset ini sangat berguna untuk menganalisis kepuasan pelanggan berdasarkan skor ulasan dan untuk memahami umpan balik pelanggan melalui komentar yang diberikan.

- Analisis ini dapat digunakan untuk meningkatkan kualitas produk dan layanan dengan menanggapi feedback pelanggan secara tepat waktu.

6. Data orders_df
"""

# prompt: orders_df.info()

orders_df.info()

"""Informasi Kolom dan Tipe Data:

- orders_df memiliki 99,441 baris dan 8 kolom.

- Kolom terdiri dari **order_id, customer_id, order_status, order_purchase_timestamp** data sudah benar, sedangkan **order_approved_at, order_delivered_carrier_date, order_delivered_customer_date, dan order_estimated_delivery_date** masih ada kesalahan dan perlu diperbaiki berikut perbaikannya.

```
# Ini diformat sebagai kode
# Mengonversi kolom waktu yang masih bertipe object menjadi datetime64[ns]
orders_df['order_approved_at'] = pd.to_datetime(orders_df['order_approved_at'], errors='coerce')
orders_df['order_delivered_carrier_date'] = pd.to_datetime(orders_df['order_delivered_carrier_date'], errors='coerce')
orders_df['order_delivered_customer_date'] = pd.to_datetime(orders_df['order_delivered_customer_date'], errors='coerce')
orders_df['order_estimated_delivery_date'] = pd.to_datetime(orders_df['order_estimated_delivery_date'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(orders_df.info())

```

- Kolom order_purchase_timestamp bertipe datetime64[ns], sementara kolom lainnya **order_approved_at, order_delivered_carrier_date, order_delivered_customer_date, dan order_estimated_delivery_date** bertipe object sudah diperbaiki dibawah ini.
"""

# Mengonversi kolom waktu yang masih bertipe object menjadi datetime64[ns]
orders_df['order_approved_at'] = pd.to_datetime(orders_df['order_approved_at'], errors='coerce')
orders_df['order_delivered_carrier_date'] = pd.to_datetime(orders_df['order_delivered_carrier_date'], errors='coerce')
orders_df['order_delivered_customer_date'] = pd.to_datetime(orders_df['order_delivered_customer_date'], errors='coerce')
orders_df['order_estimated_delivery_date'] = pd.to_datetime(orders_df['order_estimated_delivery_date'], errors='coerce')

# Memeriksa hasil perubahan tipe data
print(orders_df.info())

"""âœ… Ringkasan Struktur Data

ðŸ“Œ Total Data: 99.441 entri (baris)

ðŸ“Œ Jumlah Kolom: 8

ðŸ“Œ Tipe Data:

- 4 kolom bertipe object (teks/string) â†’ order_id, customer_id, order_status, order_purchase_timestamp
- 4 kolom bertipe datetime64[ns] â†’ order_approved_at, order_delivered_carrier_date, order_delivered_customer_date, order_estimated_delivery_date
"""

# prompt: orders_df.isna().sum()

orders_df.isna().sum()

"""Missing Values:

- Kolom order_approved_at, order_delivered_carrier_date, dan order_delivered_customer_date memiliki beberapa missing values. Kolom order_approved_at memiliki 160 missing values, order_delivered_carrier_date memiliki 1,783 missing values, dan order_delivered_customer_date memiliki 2,965 missing values.

- Kolom lainnya tidak memiliki missing values dan terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", orders_df.duplicated().sum())

print("Jumlah duplikasi: ", orders_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: orders_df.describe(include=('all'))

orders_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom order_purchase_timestamp memberikan informasi tentang kapan pesanan dilakukan.

- Kolom order_status menunjukkan status pesanan, seperti delivered, shipped, invoiced, dll.

- Kolom order_estimated_delivery_date menunjukkan perkiraan waktu pengiriman untuk setiap pesanan.

**Insight: Data order_payment_df**
- Data pesanan di orders_df bersih dari duplikasi, meskipun terdapat beberapa missing values di kolom tertentu yang berhubungan dengan status dan waktu pengiriman.

- Informasi dalam dataset ini sangat berguna untuk menganalisis efisiensi proses pemesanan dan pengiriman, memahami pola pembelian pelanggan, serta mengevaluasi kinerja pengiriman terhadap estimasi waktu pengiriman yang diberikan.

7. Data product_category_df
"""

# prompt: product_category_df.info()

product_category_name_translation_df.info()

"""Informasi Kolom dan Tipe Data:

- product_category_name_translation_df memiliki 71 baris dan 2 kolom.

- Kolom terdiri dari product_category_name dan product_category_name_english, keduanya bertipe object.
"""

# prompt: product_category_df.isna().sum()

product_category_name_translation_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", product_category_df.duplicated().sum())

print("Jumlah duplikasi: ", product_category_name_translation_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: product_category_df.describe(include=('all'))

product_category_name_translation_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom product_category_name dan product_category_name_english memberikan informasi tentang terjemahan nama kategori produk dari bahasa Portugis ke bahasa Inggris.

**Insight: Data order_payment_df**
- Data kategori produk di product_category_name_translation_df bersih dan lengkap, tanpa adanya missing values atau duplikasi.

- Informasi dalam dataset ini sangat berguna untuk mengklasifikasikan produk berdasarkan kategori yang diterjemahkan, mendukung analisis dan pelaporan yang lebih baik.

8. Data products_df
"""

# prompt: products_df.info()

products_df.info()

"""Informasi Kolom dan Tipe Data:

- products_df memiliki 32,951 baris dan 9 kolom.

- Kolom terdiri dari product_id, product_category_name, product_name_lenght, product_description_lenght, product_photos_qty, product_weight_g, product_length_cm, product_height_cm, dan product_width_cm.

- Kolom product_name_lenght, product_description_lenght, product_photos_qty, product_weight_g, product_length_cm, product_height_cm, dan product_width_cm bertipe float64, sedangkan kolom product_id dan product_category_name bertipe object.
"""

# prompt: products_df.isna().sum()

products_df.isna().sum()

"""Missing Values:

- Kolom product_category_name, product_name_lenght, product_description_lenght, dan product_photos_qty memiliki missing values. Masing-masing kolom ini memiliki sekitar 610 missing values.

- Kolom product_weight_g, product_length_cm, product_height_cm, dan product_width_cm memiliki 2 missing values masing-masing.

- Kolom product_id terisi penuh tanpa missing values.
"""

# prompt: print("Jumlah duplikasi: ", products_df.duplicated().sum())

print("Jumlah duplikasi: ", products_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: products_df.describe(include=('all'))

products_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom product_name_lenght, product_description_lenght, product_photos_qty, product_weight_g, product_length_cm, product_height_cm, dan product_width_cm menunjukkan variasi dalam atribut produk, membantu dalam memahami karakteristik produk yang berbeda.

**Insight: Data order_payment_df**
- Data produk di products_df sebagian besar bersih dan lengkap, meskipun ada beberapa missing values pada atribut produk tertentu.

- Informasi dalam dataset ini sangat berguna untuk menganalisis karakteristik produk, kinerja kategori produk, dan memahami preferensi pelanggan terhadap produk tertentu.

- Analisis ini dapat digunakan untuk meningkatkan penawaran produk dan strategi pemasaran berdasarkan atribut produk yang relevan.

9. Data sellers_df
"""

# prompt: sellers_df.info()

sellers_df.info()

"""Informasi Kolom dan Tipe Data:

- sellers_df memiliki 3,095 baris dan 4 kolom.

- Kolom terdiri dari seller_id, seller_zip_code_prefix, seller_city, dan seller_state.

- Kolom seller_zip_code_prefix bertipe int64, sedangkan kolom lainnya bertipe object.
"""

# prompt: sellers_df.isna().sum()

sellers_df.isna().sum()

"""Missing Values:

- Tidak ada missing values di dalam dataset ini. Semua kolom terisi penuh dengan nilai yang valid.
"""

# prompt: print("Jumlah duplikasi: ", sellers_df.duplicated().sum())

print("Jumlah duplikasi: ", sellers_df.duplicated().sum())

"""Duplikasi Data:

- Tidak ada duplikasi data ditemukan di dalam dataset ini (Jumlah duplikasi: 0).
"""

# prompt: sellers_df.describe(include=('all'))

sellers_df.describe(include='all')

"""Statistik Deskriptif:

- Kolom seller_zip_code_prefix menunjukkan variasi kode pos penjual.

- Kolom seller_city dan seller_state memberikan informasi tentang distribusi geografis penjual di berbagai kota dan negara bagian.

**Insight: Data order_payment_df**
- Data penjual di sellers_df bersih dan lengkap, tanpa adanya missing values atau duplikasi.

- Informasi dalam dataset ini sangat berguna untuk menganalisis distribusi geografis penjual dan lokasi mereka.

- Dataset ini mendukung evaluasi kinerja penjual dan memastikan ketersediaan produk di berbagai wilayah.

### Cleaning Data

**1. Data Duplikat**

Data duplikat terdeteksi pada geolocation_df. Namun, data tidak dihapus karena duplikasi mencerminkan variasi kode pos yang valid di wilayah yang sama, seperti "Sao Paulo," yang memiliki frekuensi tertinggi dalam kolom geolocation_city dan geolocation_state. Duplikasi ini dianggap tidak mengganggu analisis atau relevan untuk representasi lokasi geografis.
"""

# Mengecek jumlah data duplikat
duplicates = geolocation_df.duplicated().sum()
print(f"Jumlah data duplikat: {duplicates}")

# Menampilkan baris duplikat
duplicate_rows = geolocation_df[geolocation_df.duplicated()]
print(duplicate_rows)

"""**2. Missing Value**

Berdasarkan statistik deskriptif yang ada, kita mengidentifikasi missing values pada data order_reviews_df pada **Kolom review_comment_title** & **Kolom review_comment_message**:
"""

# prompt: order_reviews_df[order_reviews_df.review_comment_title.isna()]

order_reviews_df[order_reviews_df.review_comment_title.isna()]

# prompt: order_reviews_df.review_comment_title.value_counts()

order_reviews_df.review_comment_title.value_counts()

# prompt: order_reviews_df[order_reviews_df.review_comment_message.isna()]

order_reviews_df[order_reviews_df.review_comment_message.isna()]

# prompt: order_reviews_df.review_comment_message.value_counts()

order_reviews_df.review_comment_message.value_counts()

# prompt: order_reviews_df.fillna(value="sem comentÃ¡rios", inplace=True)

order_reviews_df.fillna(value="sem comentÃ¡rios", inplace=True)

"""Mengisi missing value pada kolom review_comment_title dan review_comment_message dengan value "sem comentÃ¡rios" dengan arti "no comment" adalah salah satu cara yang umum digunakan karena:
- Konsistensi: Menggunakan "sem comentÃ¡rios" memberikan konsistensi dalam data, menunjukkan bahwa tidak ada komentar yang diberikan oleh pelanggan.

- Analisis Teks: Dengan mengisi missing values dengan frasa yang umum, analisis teks menjadi lebih mudah karena kita bisa langsung mengetahui dan memisahkan ulasan yang benar-benar kosong dari ulasan yang memiliki konten.

- Representasi yang Mudah Dipahami: Ini adalah nilai default yang mudah dipahami oleh tim analisis data dan pemangku kepentingan lainnya.
"""

# prompt: order_reviews_df.isna().sum()

order_reviews_df.isna().sum()

"""Penyelesaian Missing Values:
- Missing value pada kolom review_comment_title dan review_comment_message telah diatasi dengan mengisi nilai yang hilang menggunakan metode tertentu (misalnya diisi dengan nilai "sem comentÃ¡rios" atau string kosong). Data tersebut menunjukkan jumlah missing values (nilai yang hilang) di setiap kolom dari DataFrame order_reviews_df. Kolom-kolom yang ditampilkan adalah: review_id, order_id, review_score, review_comment_title, review_comment_message, review_creation_date, dan review_answer_timestamp.

**3. Tipe Data**
"""

# prompt: # Definisikan kolom yang perlu diubah ke tipe datetime
# kolom_datetime = ["shipping_limit_date"]
# # Ubah setiap kolom dalam daftar ke tipe datetime menggunakan iterasi
# for kolom in kolom_datetime:
#     order_items_df[kolom] = pd.to_datetime(order_items_df[kolom])

# Definisikan kolom yang perlu diubah ke tipe datetime
kolom_datetime = ["shipping_limit_date"]

# Ubah setiap kolom dalam daftar ke tipe datetime menggunakan iterasi
for kolom in kolom_datetime:
    order_items_df[kolom] = pd.to_datetime(order_items_df[kolom], errors='coerce')

"""Mengubah tipe data kolom shipping_limit_date dalam DataFrame order_items_df menjadi tipe datetime. Ini penting untuk mempermudah analisis data yang melibatkan tanggal, seperti menghitung durasi pengiriman atau memfilter data berdasarkan rentang waktu tertentu."""

# prompt: order_items_df.info()

print(order_items_df.info())

# prompt: # Tentukan daftar kolom yang perlu diubah menjadi tipe datetime
# kolom_tanggal = ["review_creation_date", "review_answer_timestamp"]
# # Ubah setiap kolom dalam daftar tersebut menjadi tipe datetime
# for kolom in kolom_tanggal:
#     order_reviews_df[kolom] = pd.to_datetime(order_reviews_df[kolom])

# Tentukan daftar kolom yang perlu diubah menjadi tipe datetime
kolom_tanggal = ["review_creation_date", "review_answer_timestamp"]

# Ubah setiap kolom dalam daftar tersebut menjadi tipe datetime
for kolom in kolom_tanggal:
    order_reviews_df[kolom] = pd.to_datetime(order_reviews_df[kolom], errors='coerce')

# prompt: order_reviews_df.info()

print(order_reviews_df.info())

# Tentukan kolom yang perlu diubah menjadi tipe datetime
kolom_waktu = [
    "order_purchase_timestamp",
    "order_approved_at",
    "order_delivered_carrier_date",
    "order_delivered_customer_date",
    "order_estimated_delivery_date"
]

# Konversi setiap kolom dalam daftar menjadi tipe datetime
for kol in kolom_waktu:
    orders_df[kol] = pd.to_datetime(orders_df[kol])

# prompt: orders_df.info()

print(orders_df.info())

"""Mengubah tipe data pada kolom-kolom tertentu dalam DataFrame orders_df menjadi tipe datetime.

**Insight:**
- Konsistensi Data: Proses pembersihan ini memastikan bahwa data menjadi lebih konsisten dan siap untuk analisis lebih lanjut.

- Kemudahan Analisis: Mengatasi missing values dan mengonversi tipe data membantu dalam melakukan analisis yang lebih mendalam dan akurat.

- Relevansi Data: Mempertahankan data duplikat yang valid memastikan bahwa analisis geografis tetap akurat dan relevan.

## Exploratory Data Analysis (EDA)

### Explore ...

**1. Statistik Deskriptif dari customers_df**
"""

# Statistik deskriptif dari customers_df
print(customers_df.describe(include="all"))

# Contoh acak dari customers_df
print(customers_df.sample(5))

# Cek apakah customer_id unik
is_unique = customers_df.customer_id.is_unique
print(f"Apakah customer_id unik? {is_unique}")

# Jumlah unik ID pelanggan per kota
unique_customers_city = customers_df.groupby(by="customer_city").customer_id.nunique().sort_values(ascending=False)
print("Jumlah unik ID pelanggan per kota:")
print(unique_customers_city)

# Jumlah unik ID pelanggan per negara bagian
unique_customers_state = customers_df.groupby(by="customer_state").customer_id.nunique().sort_values(ascending=False)
print("Jumlah unik ID pelanggan per negara bagian:")
print(unique_customers_state)

"""**2. Statistik Deskriptif dari order_payments_df**"""

# Statistik deskriptif dari order_payments_df
print(order_payments_df.describe(include="all"))

# Contoh acak dari order_payments_df
print(order_payments_df.sample(5))

# Jumlah unik ID pesanan per tipe pembayaran
unique_orders_payment_type = order_payments_df.groupby(by="payment_type").order_id.nunique().sort_values(ascending=False)
print("Jumlah unik ID pesanan per tipe pembayaran:")
print(unique_orders_payment_type)

"""**3. Data orders_df**"""

# prompt: orders_df.sample(5)

print(orders_df.sample(5))

# prompt: # Menghitung selisih waktu pengiriman dalam detik
# selisih_waktu_pengiriman = orders_df["order_delivered_customer_date"] - orders_df["order_delivered_carrier_date"]
# selisih_waktu_pengiriman = selisih_waktu_pengiriman.apply(lambda x: x.total_seconds())
# # Menambahkan kolom delivery_days dalam hari
# orders_df["delivery_days"] = round(selisih_waktu_pengiriman / 86400)

# Menghitung selisih waktu pengiriman dalam detik
selisih_waktu_pengiriman = orders_df["order_delivered_customer_date"] - orders_df["order_delivered_carrier_date"]
selisih_waktu_pengiriman = selisih_waktu_pengiriman.dt.total_seconds() # Use dt accessor for datetime objects
# Menambahkan kolom delivery_days dalam hari
orders_df["delivery_days"] = round(selisih_waktu_pengiriman / 86400)

# prompt: orders_df.sample(5)

print(orders_df.sample(5))

# Membuat daftar customer_id dari orders_df
daftar_customer_id = orders_df["customer_id"].tolist()

# Menandai status pelanggan sebagai "Active" atau "Non Active" di customers_df
customers_df["status"] = customers_df["customer_id"].apply(lambda id: "Active" if id in daftar_customer_id else "Non Active")

# Menampilkan 10 baris acak dari customers_df setelah penambahan kolom status
print(customers_df.sample(10))

# prompt: ustomers_df.groupby(by="status").customer_id.count()

print(customers_df.groupby(by="status").customer_id.count())

"""**4. Menggabungkan data customers_df dan orders_df**"""

# Menggabungkan DataFrame customers_df dengan orders_df
customers_orders_merged = customers_df.merge(
    orders_df,
    how="left",
    on="customer_id"
)
# Menampilkan 5 baris pertama dari hasil penggabungan
print(customers_orders_merged.head())

# Menggabungkan DataFrame customers_df dengan orders_df
customers_orders_df = customers_df.merge(orders_df, how="left", on="customer_id")

# Menentukan 10 kota teratas berdasarkan jumlah pesanan unik
top_10_cities = customers_orders_df.groupby("customer_city").order_id.nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print(top_10_cities)

# Asumsikan customers_orders_df sudah terdefinisi dan terisi seperti dalam konteks yang diberikan
top_10_states = customers_orders_df.groupby("customer_state")["order_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 negara bagian teratas berdasarkan jumlah pesanan unik:")
print(top_10_states)

# Mengelompokkan data berdasarkan customer_state dan menghitung jumlah unik order_id
top_10_states = customers_orders_df.groupby("customer_state")["order_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 negara bagian teratas berdasarkan jumlah pesanan unik:")
print(top_10_states)

# Mengelompokkan data berdasarkan customer_zip_code_prefix dan menghitung jumlah unik order_id
top_10_zip_codes = customers_orders_df.groupby("customer_zip_code_prefix")["order_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 kode pos teratas berdasarkan jumlah pesanan unik:")
print(top_10_zip_codes)

"""**5. Menggabungkan data order_payments_df dan order_reviews_df**"""

# Menggabungkan DataFrame order_payments_df dengan order_reviews_df
merged_order_payment_reviews = order_payments_df.merge(
    order_reviews_df,
    how="left",
    on="order_id"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(merged_order_payment_reviews.head())

# Menggabungkan DataFrame order_payments_df dengan order_reviews_df
order_payment_reviews_df = order_payments_df.merge(order_reviews_df, how="left", on="order_id")

# Mengelompokkan data berdasarkan payment_type dan menghitung jumlah unik order_id
top_10_payment_methods = order_payment_reviews_df.groupby("payment_type")["order_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 metode pembayaran teratas berdasarkan jumlah pesanan unik:")
print(top_10_payment_methods)

# Mengurutkan data berdasarkan nilai pembayaran secara menurun
sorted_order_payments_reviews = order_payment_reviews_df.sort_values("payment_value", ascending=False)

# Menampilkan data
print(sorted_order_payments_reviews[['order_id', 'payment_sequential', 'payment_type', 'payment_installments', 'payment_value', 'review_id', 'review_score', 'review_comment_title', 'review_comment_message', 'review_creation_date', 'review_answer_timestamp']])

# Mengelompokkan data berdasarkan payment_type dan melakukan agresi
order_payment_reviews_df.groupby(by="payment_type").agg({
    "order_id": "nunique",
    "payment_value":  ["min", "max"]
})

"""**6. Membuat data customers baru**"""

# Menggabungkan DataFrame customers_orders_df dengan order_payment_reviews_df
new_customers_df = customers_orders_df.merge(
    order_payment_reviews_df,
    how="left",
    on="order_id"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(new_customers_df.head())

"""**7. Menggabungkan data orders_item_df dan sellers_df**"""

# Menggabungkan DataFrame order_items_df dengan sellers_df
order_items_seller_df = order_items_df.merge(
    sellers_df,
    how="left",
    on="seller_id"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(order_items_seller_df.head())

# Mengelompokkan data berdasarkan seller_city dan menghitung jumlah unik seller_id
top_10_seller_cities = order_items_seller_df.groupby("seller_city")["seller_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 kota dengan jumlah penjual unik terbanyak:")
print(top_10_seller_cities)

# Mengelompokkan data berdasarkan seller_state dan menghitung jumlah unik seller_id
top_10_seller_states = order_items_seller_df.groupby("seller_state")["seller_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 negara bagian dengan jumlah penjual unik terbanyak:")
print(top_10_seller_states)

"""**8. Membuat data product baru**"""

# Menggabungkan DataFrame products_df dengan product_category_name_translation_df
new_product_df = products_df.merge(
    product_category_name_translation_df,
    how="left",
    on="product_category_name"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(new_product_df.head())

# Mengelompokkan data berdasarkan product_category_name dan menghitung jumlah unik product_id
top_10_product_categories = new_product_df.groupby("product_category_name")["product_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 kategori produk teratas berdasarkan jumlah produk unik:")
print(top_10_product_categories)

# Mengelompokkan data berdasarkan product_category_name_english dan menghitung jumlah unik product_id
top_10_product_categories_english = new_product_df.groupby("product_category_name_english")["product_id"].nunique().sort_values(ascending=False).head(10)

# Menampilkan hasil
print("10 kategori produk teratas berdasarkan jumlah produk unik (bahasa Inggris):")
print(top_10_product_categories_english)

"""**9. Menggabungkan data order_items_seller_df dan new_product_df**"""

# Menggabungkan DataFrame new_product_df dengan order_items_seller_df
new_sellers_df = new_product_df.merge(
    order_items_seller_df,
    how="left",
    on="product_id"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(new_sellers_df.head())

# prompt: new_sellers_df.sort_values(by="price", ascending=False)

new_sellers_df.sort_values(by="price", ascending=False)

# prompt:

new_sellers_df.groupby(by="product_category_name_english").agg({
    "order_id": "nunique",
    "price":  ["min", "max"]
})

"""**10. Menggabungkan semua data**"""

# Menggabungkan DataFrame new_customers_df dengan new_sellers_df
all_data = new_customers_df.merge(
    new_sellers_df,
    how="left",
    on="order_id"
)

# Menampilkan 5 baris pertama dari hasil penggabungan
print(all_data.head())

all_data.info()

# prompt: Mengelompokkan data berdasarkan customer_city dan priduct_category_name_english, lalu menghitung total price freight_value

all_data.groupby(by=["customer_city", "product_category_name_english"]).agg({
    "price": "sum",
    "freight_value": "sum"
})

# prompt: Mengelompokkan data berdasarkan customer_state dan product_category_name_english, lalu menghitung total_price dan freight_value
all_data.groupby(by=["customer_state", "product_category_name_english"]).agg({
    "price": "sum",
    "freight_value": "sum"
})

# Mengelompokkan data berdasarkan customer_state, menghitung jumlah pesanan unik dan total nilai pembayaran, lalu mengurutkan berdasarkan payment_value secara menurun
grouped_data = all_data.groupby("customer_state").agg({
    "order_id": "nunique",
    "payment_value": "sum"
}).sort_values(by="payment_value", ascending=False)

# Menampilkan hasil
print(grouped_data)

# prompt: Mengelompokkan data berdasarkan product_category_name_english, menghitung jumlah pesanan unik, dan mencari nilai minimum dan maksimum dari review_score

all_data.groupby(by="product_category_name_english").agg({
    "order_id": "nunique",
    "review_score":  ["min", "max"]
})

"""**11. Data geolocation_df dieksplorasi**"""

# Melihat beberapa baris pertama dari geolocation_df
print(geolocation_df.head())

# Melihat informasi ringkasan tentang geolocation_df
print(geolocation_df.info())

# Melihat statistik deskriptif dari geolocation_df
print(geolocation_df.describe())

# Memeriksa data yang hilang
print(geolocation_df.isnull().sum())

# Mengelompokkan data berdasarkan negara bagian dan menghitung jumlah lokasi unik
location_distribution = geolocation_df.groupby('customer_state')['customer_zip_code_prefix'].nunique()
print(location_distribution.sort_values(ascending=False))

"""**12. Membuat data baru yang sebelumnya telah di bersihkan dan di eksplorasi**"""

import os
# Check if the directory exists and if not create it
if not os.path.exists('streamlit'):
    os.makedirs('streamlit')

all_data.to_csv('streamlit/all_data.csv', index=False)

"""**Insight:**
- **Distribusi Geografis Pelanggan**: Analisis ini menunjukkan distribusi pelanggan berdasarkan wilayah geografis, membantu memahami pasar geografis yang paling aktif.
- **Kategori Produk dengan Ulasan Terbaik**: Analisis ini mengidentifikasi kategori produk yang mendapat ulasan terbaik, membantu fokus pada kategori produk yang lebih memuaskan pelanggan.

## Visualization & Explanatory Analysis

### Pertanyaan 1: Produk apa saja yang menunjukkan performa penjualan terbaik dan terburuk di E-commerce?
"""

# Produk dengan performa penjualan terbaik dan terburuk
# Hitung jumlah penjualan per produk
product_sales = order_items_df.groupby('product_id')['order_item_id'].count().reset_index()

# Gabungkan dengan tabel produk untuk mendapatkan nama produk
product_sales = product_sales.merge(products_df[['product_id', 'product_category_name']], on='product_id', how='left')

# Urutkan berdasarkan jumlah penjualan
best_selling_products = product_sales.sort_values(by='order_item_id', ascending=False).head(10)
worst_selling_products = product_sales.sort_values(by='order_item_id', ascending=True).head(10)

# Visualisasi
plt.figure(figsize=(14,7))

# Produk dengan penjualan terbaik
plt.subplot(1, 2, 1)
plt.bar(best_selling_products['product_category_name'], best_selling_products['order_item_id'], color='green')
plt.title('Top 10 Best Selling Products')
plt.xticks(rotation=45, ha='right')

# Produk dengan penjualan terburuk
plt.subplot(1, 2, 2)
plt.bar(worst_selling_products['product_category_name'], worst_selling_products['order_item_id'], color='red')
plt.title('Top 10 Worst Selling Products')
plt.xticks(rotation=45, ha='right')

plt.tight_layout()
plt.show()

"""### Pertanyaan 2: Bagaimana pola tren penjualan E-commerce selama periode waktu tertentu?"""

# Pola tren penjualan E-commerce
# Memastikan kolom order_purchase_timestamp ada
if 'order_purchase_timestamp' not in orders_df.columns:
    orders_df.reset_index(inplace=True)

# Konversi ke tipe datetime
orders_df['order_purchase_timestamp'] = pd.to_datetime(orders_df['order_purchase_timestamp'], errors='coerce')

# Set sebagai index & resample per bulan
orders_df.set_index('order_purchase_timestamp', inplace=True)

# Memastikan index bertipe datetime sebelum resampling
if not isinstance(orders_df.index, pd.DatetimeIndex):
    raise ValueError("Index is not a DatetimeIndex. Check order_purchase_timestamp format.")

# Resample data untuk tren penjualan bulanan
monthly_sales = orders_df.resample('ME').size()

# Plot tren penjualan bulanan
plt.figure(figsize=(14,7))
plt.plot(monthly_sales.index, monthly_sales.values, marker='o', linestyle='-', color='b')
plt.title('Monthly Sales Trend', fontsize=14)
plt.xlabel('Month', fontsize=12)
plt.ylabel('Number of Orders', fontsize=12)
plt.xticks(rotation=45)
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

"""### Pertanyaan 3: Berapa jumlah pendapatan yang dihasilkan oleh E-commerce dalam periode beberapa bulan terakhir?"""

# Jumlah pendapatan yang dihasilkan
order_payments_df['payment_value'] = order_payments_df['payment_value'].astype(float)
monthly_revenue = order_payments_df.groupby(order_payments_df['payment_sequential']).sum()
monthly_revenue.plot(kind='bar', figsize=(14,7))
plt.title('Monthly Revenue')
plt.xlabel('Month')
plt.ylabel('Revenue')
plt.show()

"""### Pertanyaan 4: Apa saja ulasan dan rating yang diberikan oleh pelanggan kepada E-commerce, dan bagaimana persebarannya?"""

# Ulasan dan rating yang diberikan oleh pelanggan
# Review_score berbentuk numerik
order_reviews_df['review_score'] = pd.to_numeric(order_reviews_df['review_score'], errors='coerce')

# Hitung distribusi rating & urutkan
reviews_distribution = order_reviews_df['review_score'].value_counts().sort_index()

# Atur warna menggunakan colormap
colors = sns.color_palette("coolwarm", len(reviews_distribution))

# Plot grafik batang
plt.figure(figsize=(12, 6))
bars = plt.bar(reviews_distribution.index, reviews_distribution.values, color=colors, alpha=0.85)

# Tambahkan label jumlah di atas batang
for bar in bars:
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height(), f'{int(bar.get_height())}', ha='center', va='bottom', fontsize=11, fontweight='bold')

# Judul dan label
plt.title('Distribution of Customer Reviews', fontsize=14, fontweight='bold')
plt.xlabel('Review Score', fontsize=12)
plt.ylabel('Number of Reviews', fontsize=12)

# Atur sumbu X agar hanya menampilkan skor review yang ada
plt.xticks(reviews_distribution.index, fontsize=11)

# Tambahkan grid horizontal untuk membantu membaca jumlah
plt.grid(axis='y', linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

"""Melihat kata-kata Ulasan yang paling sering muncul di review pelanggan"""

from wordcloud import WordCloud
from collections import Counter

# Pastikan kolom ulasan tidak memiliki nilai NaN
all_reviews = " ".join(order_reviews_df['review_comment_message'].dropna())

# Hitung frekuensi kata
word_counts = Counter(all_reviews.split())

# Buat Word Cloud
wordcloud = WordCloud(width=800, height=400, background_color='white', colormap='viridis').generate(all_reviews)

# Ambil 10 kata paling sering muncul
top_words = dict(word_counts.most_common(10))

# Plot Word Cloud
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.title("Word Cloud of Customer Reviews")

# Plot Diagram Batang dengan Label Jumlah
plt.subplot(1, 2, 2)
bars = plt.bar(top_words.keys(), top_words.values(), color='blue', alpha=0.7)

# Tambahkan label jumlah di atas setiap batang
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval}', ha='center', va='bottom', fontsize=10, fontweight='bold')

plt.xlabel("Words")
plt.ylabel("Frequency")
plt.title("Top 10 Most Frequent Words in Reviews")
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

"""Analisis Sentimen apakah ulasan pelanggan lebih cenderung positif, negatif, atau netral."""

from textblob import TextBlob

# Fungsi untuk mendapatkan sentimen
def get_sentiment(text):
    if pd.isna(text):  # Jika review kosong
        return "Neutral"
    analysis = TextBlob(text)
    if analysis.sentiment.polarity > 0:
        return "Positive"
    elif analysis.sentiment.polarity < 0:
        return "Negative"
    else:
        return "Neutral"

# Tambahkan kolom sentimen ke dalam dataframe
order_reviews_df['sentiment'] = order_reviews_df['review_comment_message'].apply(get_sentiment)

# Hitung distribusi sentimen
sentiment_distribution = order_reviews_df['sentiment'].value_counts()

# Plot hasil analisis sentimen dengan label jumlah di atas batang
plt.figure(figsize=(8, 5))
bars = plt.bar(sentiment_distribution.index, sentiment_distribution.values, color=['green', 'gray', 'red'], alpha=0.7)

# Tambahkan label jumlah di atas setiap batang
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval, f'{yval}', ha='center', va='bottom', fontsize=10, fontweight='bold')

plt.title('Sentiment Analysis of Customer Reviews')
plt.xlabel('Sentiment')
plt.ylabel('Number of Reviews')
plt.xticks(rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Menganalisis kata-kata yang sering muncul untuk setiap kategori sentimen
sentiment_words = {
    "Positive": Counter(),
    "Negative": Counter(),
    "Neutral": Counter()
}

# Memproses setiap review berdasarkan sentimen
for index, row in order_reviews_df.iterrows():
    sentiment = row['sentiment']
    if pd.notna(row['review_comment_message']):  # Pastikan ada teks
        words = row['review_comment_message'].split()
        sentiment_words[sentiment].update(words)

# Menampilkan 10 kata paling sering muncul di setiap kategori sentimen
for sentiment, word_count in sentiment_words.items():
    print(f"\nTop 10 words in {sentiment} reviews:")
    for word, count in word_count.most_common(10):
        print(f"{word}: {count}")

"""### Pertanyaan 5: Bagaimana distribusi demografis pelanggan dan apakah ada variasi dalam preferensi pembelian di antara mereka?"""

# Penyebaran distribusi geaografis
# Distribusi jumlah pelanggan per negara bagian
customer_distribution = customers_df['customer_state'].value_counts()

# Distribusi jumlah pesanan per negara bagian
order_distribution = orders_df.merge(customers_df, on='customer_id')['customer_state'].value_counts()

# Distribusi total nilai pembelian per negara bagian
order_payments_df['payment_value'] = order_payments_df['payment_value'].astype(float)
revenue_distribution = orders_df.merge(customers_df, on='customer_id').merge(order_payments_df, on='order_id').groupby('customer_state')['payment_value'].sum()

# Membuat subplots untuk membandingkan distribusi
fig, axes = plt.subplots(3, 1, figsize=(14, 15))

# Plot distribusi jumlah pelanggan
customer_distribution.plot(kind='bar', ax=axes[0], color='cornflowerblue', alpha=0.8)
axes[0].set_title('Customer Demographics by State')
axes[0].set_xlabel('State')
axes[0].set_ylabel('Number of Customers')
axes[0].grid(axis='y', linestyle='--', alpha=0.7)

# Plot distribusi jumlah pesanan
order_distribution.plot(kind='bar', ax=axes[1], color='salmon', alpha=0.8)
axes[1].set_title('Order Distribution by State')
axes[1].set_xlabel('State')
axes[1].set_ylabel('Number of Orders')
axes[1].grid(axis='y', linestyle='--', alpha=0.7)

# Plot distribusi total revenue
revenue_distribution.plot(kind='bar', ax=axes[2], color='mediumseagreen', alpha=0.8)
axes[2].set_title('Total Revenue by State')
axes[2].set_xlabel('State')
axes[2].set_ylabel('Total Revenue')
axes[2].grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

"""**Insight:**
- **Produk dengan Performa Penjualan Terbaik dan Terburuk**: Visualisasi ini menunjukkan produk-produk yang paling laris dan paling sedikit terjual.
- **Pola Tren Penjualan**: Analisis ini menunjukkan perubahan volume penjualan dari waktu ke waktu, membantu memahami tren musiman atau faktor lain yang mempengaruhi penjualan.
- **Pendapatan Bulanan**: Memahami pendapatan bulanan membantu mengevaluasi kinerja keuangan secara lebih rinci.
- **Distribusi Ulasan Pelanggan**: Analisis ulasan membantu mengidentifikasi kepuasan dan pengalaman pelanggan.
- **Distribusi Demografis Pelanggan**: Memahami distribusi demografis pelanggan membantu menyesuaikan strategi pemasaran dan layanan.

## Analisis Lanjutan (Opsional)
"""



"""## Conclusion

- **Produk apa saja yang menunjukkan performa penjualan terbaik dan terburuk di E-commerce?**

  ðŸ“Œ Temuan:

  - Produk dengan performa penjualan terbaik menunjukkan bahwa beberapa produk sangat populer di kalangan pelanggan.
  - Produk dengan penjualan terburuk dapat menjadi fokus untuk pengembangan produk lebih lanjut atau strategi pemasaran baru.

  ðŸ“Œ Implikasi:

  - Produk dengan performa terbaik dapat lebih dioptimalkan dengan promosi dan peningkatan stok.
  - Produk dengan performa terburuk perlu dianalisis lebih lanjut apakah layak untuk ditingkatkan atau dikeluarkan dari katalog.

- **Bagaimana pola tren penjualan E-commerce selama periode waktu tertentu?**

  ðŸ“Œ Temuan:

  - Pola tren penjualan menunjukkan adanya fluktuasi bulanan dalam volume penjualan. Ini bisa disebabkan oleh faktor musiman, kampanye promosi, atau perilaku pelanggan lainnya.
  - Beberapa bulan menunjukkan penurunan yang mungkin disebabkan oleh musim sepi atau kurangnya kampanye promosi.

  ðŸ“Œ Implikasi:

  - Menyesuaikan strategi pemasaran dan stok berdasarkan pola musiman.
  - Mengoptimalkan periode dengan penjualan rendah dengan promosi atau insentif bagi pelanggan.

- **Berapa jumlah pendapatan yang dihasilkan oleh E-commerce dalam periode beberapa bulan terakhir?**

  ðŸ“Œ Temuan:

  - Pendapatan bulanan membantu mengevaluasi kinerja keuangan dan memahami kapan puncak penjualan terjadi yang mungkin berkaitan dengan promosi atau tren musiman.
  - Adanya penurunan pada bulan-bulan tertentu dapat menjadi indikator adanya masalah dalam permintaan pasar atau strategi pemasaran.

  ðŸ“Œ Implikasi:

  - Fokus pada strategi pemasaran berbasis data untuk meningkatkan penjualan selama periode rendah.
  - Melakukan kampanye promosi pada bulan-bulan tertentu untuk meningkatkan pendapatan secara berkelanjutan.

- **Apa saja ulasan dan rating yang diberikan oleh pelanggan kepada E-commerce, dan bagaimana persebarannya?**

  ðŸ“Œ Temuan:

  - Distribusi ulasan pelanggan menunjukkan tingkat kepuasan dan membantu dalam meningkatkan kualitas produk dan layanan.
  - Beberapa pelanggan memberikan rating rendah, dan analisis sentimen menunjukkan keluhan terkait pengiriman, kualitas produk, atau layanan pelanggan.

  ðŸ“Œ Implikasi:

  - Meningkatkan kualitas layanan berdasarkan umpan balik pelanggan, terutama pada aspek yang paling banyak dikeluhkan.
  - Membangun sistem loyalitas atau kompensasi bagi pelanggan yang kurang puas untuk meningkatkan retensi.

- **Bagaimana distribusi demografis pelanggan dan apakah ada variasi dalam preferensi pembelian di antara mereka?**

  ðŸ“Œ Temuan:

  - Distribusi demografis pelanggan membantu dalam menargetkan segmen pasar yang tepat dan menyesuaikan strategi pemasaran.
  - Preferensi pembelian dapat bervariasi berdasarkan lokasi geografis, yang mungkin dipengaruhi oleh faktor sosial-ekonomi dan budaya.

  ðŸ“Œ Implikasi:

  - Menyesuaikan strategi pemasaran berdasarkan lokasi geografis pelanggan.
  - Menawarkan produk yang lebih sesuai dengan preferensi pelanggan di wilayah tertentu.
"""